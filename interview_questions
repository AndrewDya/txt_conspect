Виды HTTP запросов:

GET - используется для запроса данных с сервера, безопасный: только получает данные
POST - используется для отправки данных на сервер для создания новых ресурсов, небезопасный
PUT - используется для обновления существующего ресурса на сервере
PATCH - используется для частичного обновления существующего ресурса на сервере
DELETE - используется для запроса удаления ресурса на сервере
HEAD - подобен GET, но возвращает только заголовки ответа и без тела ресурса
OPTIONS - используется для запроса информации о возможных методах запроса, поддерживаемых ресурсом, и другой мета-информации


HTTP статус коды (HTTP status codes) - это числовые значения, которые сервер отправляет в ответ на HTTP-запросы, чтобы сообщить клиенту о результате запроса

1xx (Информационные коды):
100: Continue (Продолжай) - Сервер готов продолжить обработку запроса
101: Switching Protocols (Смена протоколов) - Сервер соглашается с изменением протокола, предложенного клиентом

2xx (Успешные коды):
200: OK (Успешно) - Запрос успешно обработан, и результат передается в ответе
201: Created (Создано) - Ресурс успешно создан на сервере
204: No Content (Нет содержимого) - Запрос выполнен успешно, но в ответе нет содержимого

3xx (Перенаправления):
301: Moved Permanently (Перемещено навсегда) - Ресурс был перемещен на постоянной основе, и клиент должен перейти по новому URL
302: Found (Найдено) - Ресурс временно перемещен, и клиент должен перейти по временному URL
304: Not Modified (Не изменено) - Ресурс не был изменен с момента последнего запроса, и клиент может использовать кэшированную версию

4xx (Ошибки клиента):
400: Bad Request (Неверный запрос) - Сервер не может обработать запрос из-за синтаксической ошибки или неправильных данных
401: Unauthorized (Неавторизовано) - Для доступа к ресурсу требуется аутентификация
403: Forbidden (Запрещено) - Клиент не имеет разрешения на доступ к ресурсу
404: Not Found (Не найдено) - Ресурс не найден на сервере

5xx (Ошибки сервера):
500: Internal Server Error (Внутренняя ошибка сервера) - Внутренняя ошибка сервера при обработке запроса
502: Bad Gateway (Плохой шлюз) - Сервер, выступающий в роли шлюза или прокси, получил недопустимый ответ от вышестоящего сервера
503: Service Unavailable (Сервис недоступен) - Сервер временно не может обрабатывать запросы из-за перегрузки или технических работ


Принципы SOLID:

SOLID - это аббревиатура, представляющая пять основных принципов объектно-ориентированного программирования и проектирования. 
Эти принципы помогают разработчикам создавать более чистый, гибкий и поддерживаемый код. Вот принципы SOLID и их применение в Python:

Принцип единственной ответственности (Single Responsibility Principle, SRP): Этот принцип гласит, что класс должен иметь только одну причину для изменения. 
Он должен быть ответственным только за одну часть функциональности программы. В Python это означает, что класс или функция должны выполнять только одну конкретную задачу.

Принцип открытости/закрытости (Open/Closed Principle, OCP): Согласно этому принципу, программные сущности, такие как классы, модули и функции, 
должны быть открыты для расширения (новая функциональность может быть добавлена) и закрыты для модификации (существующий код не должен изменяться). 
В Python это можно достичь, используя наследование и полиморфизм.

Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP): Этот принцип утверждает, что объекты базового класса должны быть заменяемыми 
объектами производных классов без нарушения корректности программы. В Python это означает, что производные классы должны соответствовать интерфейсу базового класса.

Принцип разделения интерфейса (Interface Segregation Principle, ISP): Согласно этому принципу, клиенты не должны зависеть от интерфейсов, которые они не используют. 
В Python это можно достичь, создавая множество узких интерфейсов, а не один большой.

Принцип инверсии зависимостей (Dependency Inversion Principle, DIP): Этот принцип гласит, что высокоуровневые модули не должны зависеть от низкоуровневых модулей, 
оба должны зависеть от абстракций. Кроме того, абстракции не должны зависеть от деталей, детали должны зависеть от абстракций. В Python это можно достичь, 
используя инъекцию зависимостей (Dependency Injection) и создавая абстракции для взаимодействия с зависимостями.


Принципы объектно-ориентированного программирования (ООП) в Python включают в себя следующие основные концепции:

Инкапсуляция (Encapsulation): Инкапсуляция означает объединение данных (переменных) и методов (функций), которые работают с этими данными, внутри класса. Класс предоставляет 
интерфейс для взаимодействия с данными, скрывая детали их реализации. В Python это достигается с использованием закрытых атрибутов и методов, которые начинаются с символа 
подчеркивания (_) или двойного символа подчеркивания (__). Однако в Python инкапсуляция не является строгой, и доступ к закрытым членам класса всё равно возможен.

Наследование (Inheritance): Наследование позволяет создавать новый класс на основе существующего класса (родительского класса). Дочерний класс (подкласс) наследует атрибуты 
и методы родительского класса и может добавлять новые или переопределять существующие методы. Это способствует повторному использованию кода и созданию иерархий классов.

Полиморфизм (Polymorphism): Полиморфизм позволяет объектам разных классов реагировать на одинаковые методы или операции таким образом, чтобы их поведение было специфичным 
для каждого класса. Это упрощает работу с различными объектами, используя общий интерфейс.

Абстракция (Abstraction): Абстракция позволяет скрыть детали реализации и предоставить только необходимые сведения для использования объекта или класса. В Python абстракция 
может быть достигнута через создание абстрактных классов с помощью модуля abc (Abstract Base Classes).


REST (Representational State Transfer) API (RESTful)– это архитектурный стиль проектирования веб-сервисов. Основные принципы REST включают:

Без состояния (Statelessness):
REST API не сохраняет информацию о состоянии клиента между запросами. Каждый запрос от клиента содержит всю необходимую информацию для его обработки на сервере. 
Это делает взаимодействие более прозрачным и уменьшает зависимость между клиентом и сервером.

Единообразие интерфейса (Uniform Interface):
REST предоставляет унифицированный интерфейс для взаимодействия с ресурсами. Это означает, что независимо от того, с каким ресурсом или сервером вы взаимодействуете, 
у вас есть общие принципы запросов (например, HTTP методы: GET, POST, PUT, DELETE) и форматы данных (часто JSON).

Кеширование ответов (Cacheable):
Серверы могут указывать, могут ли их ответы быть кешированы клиентами. Кеширование позволяет клиентам избежать повторного запроса к серверу, 
если у них уже есть актуальные данные. Это уменьшает нагрузку на сервер и улучшает производительность.

Система слоев (Layered System):
Клиент не обязательно знает, находится ли сервер прямо перед ним или через промежуточные узлы, такие как прокси-серверы или кэширующие серверы. 
Это обеспечивает модульность и гибкость системы, позволяя внести изменения в слои без воздействия на клиентов или серверы.

Многоуровневая система (Layered System):
Принцип многоуровневой системы подразумевает, что архитектура может быть разделена на слои (уровни). Каждый слой выполняет определенные функции и предоставляет 
определенные абстракции. Каждый слой взаимодействует только с ближайшими слоями, что упрощает модификацию и обновление системы.

Код по требованию (Code on Demand):
Этот принцип предполагает, что функциональность системы может быть расширена за счет передачи исполняемого кода от сервера к клиенту по запросу. 
Это позволяет клиентам выполнить часть логики на своей стороне, улучшая гибкость и возможности системы.


Вы набираете в браузере http://google.com/. Что реально происходит?

1) Браузер проверяет в локальном кэше, есть ли такая страничка;
2) Если есть, тo проверяет заголовки и параметры кэширования (Expires), можно ли её использовать;
3) Браузер запрашивает DNS и вычисляет IP для google.com;
4) Браузер составляет http-зanpoc;
5) Браузер (прикладной уровень модели OSI) передаёт запрос ниже, транспортному уровню;
6) Транспортный уровень сетевой подсистемы упаковывает запрос в TCP-пакеты и отправляет ещё ниже, сетевому уровню;
7) Сетевой и нижележащие уровни отправляют запрос в сеть согласно таблицам маршрутизации;
8) Где-то в сети потенциальные кэширующие сервера, проверяют, не могут ли они выполнить этот запрос без передачи дальше по маршруту;
9) Где-то в сети обрабатываются проверки блокировок от Роскомнадзора;
10) ТСР/IР-пакеты передаются от сервера к серверу согласно таблицам маршрутизации и наконец доходят до сетевого уровня целевого сервера;
11) Сетевой и транспортный уровни сервера собирают запрос из пакетов; 
12) Проверяется, может ли порт (в данном случае 80-й) принять запрос, есть ли место в очереди, слушает ли кто-нибудь этот порт;
13) Если порт слушается, то устанавливается сессия и запрос передаётся тому веб-серверу, который слушает порт; 
14) В нашем случае это nginx, который аллоцирует буфер для принятия запроса;
15) Если буфера в памяти не хватает, то создаётся временный файл на диске;
16) Дисковая подсистема операционной системы решает где создать временный файл - в буфере или реально на диске;
17) Nginx принимает весь запрос;
18) Только после этого nginx проверяет требуется ли выполнение запроса или он может обработать его без передачи бекенду (например, он в кэше или это картинка);
19) Если запрос требует вычисления, то открывается upstream к бэкенду;
20) Сервер, который слушает порт бэкенда открывает соединение и принимает запрос;
21) В нашем случае это Apache, последовательно выполняются 11-ть стадии выполнения запроса: трансляция в URL, проверка заголовков, вычисление скрипта, 
  который должен обработать запрос, запуск скрипта, передача скрипту информации запроса, ожидание выполнения скрипта, отдача результатов nginx'у, логирование, этап очистки;
22) Скрипт получает запрос, запускается построение страницы;
23) Выполняется программа, данные с помощью SQL-запросов запрашивается из базы данных;
24) В каждом случае устанавливается соединение с базой данных (если оно не постоянное);
25) База данных получает SQL-зaпpoc;
26) База данных строит план выполнения запроса, затем выполняет его, используя те или иные буферы;
27) При каждом чтении таблицы сначала база данных проверяет нет ли этой информации в кэше, затем дисковая подсистема делает тоже самое;
28) Скрипт собирает данные от базы данных и вставляет их в шаблон страницы;
29) Скрипт отдаёт собранную страницу веб-серверу Apache;
30) Apache передаёт собранную страницу nginx;
31) Nginx принимает страницу и только полностью записав её в локальный буфер начинает передачу пользователю. Всё это время соединение с пользователем открыто;
32) Собранная страница в обратном порядке спускается вниз по моделям OSI, бьётсядля передачи сети на кусочки;
33) Сетевой и транспортный уровень машины пользователя собирают страницу и передают её выше;
34) Браузер парсит страницу и запускает аналогичный, процесс для всех её составляющих: JS-файлов, СSS-файлов, картинок. Для каждого элемента весь процесс повторяется;
35) Только после получения всего этого начинается процесс построения странички для пользователя;
36) PS: Браузер пытается закэшировать всё, что можно.


Модель OSI представляет собой абстрактный фреймворк, разработанный для описания взаимодействия компьютерных систем в компьютерных сетях. Эта модель определена Международной 
организацией по стандартизации (ISO) с целью создания стандартизированного подхода к проектированию сетевых протоколов и обеспечения совместимости различных сетевых устройств.
Модель OSI состоит из семи уровней, каждый из которых предоставляет конкретные функции, необходимые для передачи данных от одного узла к другому в компьютерной сети. 

1) Физический уровень (Physical Layer):
Этот уровень занимается передачей битов по физической среде, такой как провода или волоконно-оптические кабели.
Пример: Какие сигналы и как быстро передаются через провода.

2) Канальный уровень (Data Link Layer):
Обеспечивает безошибочную передачу фреймов между соседними узлами на одном сегменте сети.
Пример: Мак-адреса (физические адреса) используются для идентификации устройств на одном сегменте.

3) Сетевой уровень (Network Layer):
Маршрутизация данных между разными сегментами сети. Определяет кратчайший путь для доставки пакетов.
Пример: IP-адреса используются для идентификации устройств в различных сетях.

4) Транспортный уровень (Transport Layer):
Обеспечивает эффективную и надежную передачу данных от одного узла к другому.
Пример: TCP (Transmission Control Protocol) - обеспечивает надежную передачу данных с установкой соединения и контролем потока.

5) Сеансовый уровень (Session Layer):
Управление сеансами или диалогами между приложениями на разных узлах. Устанавливает, поддерживает и завершает соединения.
Пример: Управление сеансами в виде установки и разрыва соединений.

6) Представительный уровень (Presentation Layer):
Отвечает за преобразование данных в формат, понятный для приложений.
Пример: Шифрование данных, сжатие, кодирование.

7) Прикладной уровень (Application Layer):
Предоставляет интерфейс для взаимодействия между программами и сетью. Здесь работают сами приложения.
Пример: HTTP (Hypertext Transfer Protocol) для передачи веб-страниц, SMTP (Simple Mail Transfer Protocol) для электронной почты.
