ПУНКТ 1. Терминал
Основные команды в терминале (Unix-подобные системы):

cd ~ перейти в домашний каталог 
cd <directory_name> - перейти в указанную директорию
cd .. - перейти в родительскую директорию (на один уровень выше текущей)
cd / - перейти в корневую директорию
cd - - перейти в предыдущий каталог
cd /path/to/directory - укажите полный путь к каталогу, в который вы хотите перейти
cd <Tab> - нажмите Tab после ввода начальных символов имени каталога, и терминал автоматически дополнит имя каталога, если есть однозначное соответствие
clear - очистить консоль

sudo <command> - выполнить команду от имени администратора (суперпользователя)
sudo apt update - обновить список доступных пакетов в системе
sudo apt install <package_name> - установить указанный пакет с использованием менеджера пакетов APT (Advanced Package Tool)
sudo apt upgrade - обновить установленные пакеты до последних версий

ip a - вывести информацию о сетевых интерфейсах и их настройках
ls - вывести список файлов и каталогов в текущей директории
ls -la - отобразить список файлов и каталогов в текущей директории
ls -lha - отобразить список файлов и каталогов в текущей директории в длинном формате, включая скрытые файлы
pwd - вывести путь к текущей директории (текущий рабочий каталог)
mkdir <directory> - создать новую директорию с указанным именем
rmdir <directory> - удалить пустую директорию
rm <file> - удалить указанный файл
cp <source> <destination> - скопировать файл или директорию из источника в место назначения
mv <source> <destination> - переместить файл или директорию из источника в место назначения
touch <file> - создать новый пустой файл с указанным именем
cat <file> - вывести содержимое указанного файла в консоль
nano <file> - создаёт новый пустой файл с указанным именем или редактируеи существующий файл с использованием текстового редактора Nano
grep <pattern> <file> - найти строки в указанном файле, соответствующие заданному шаблону с использованием регулярных выражений
ping <hostname_or_ip> - протестировать соединение сетевого устройства с помощью ICMP-запросов
top - вывод информации о текущих процессах в системе
ps - вывести список всех запущенных процессов
su - <user_name> - переключение на пользователя user_name
hostname -I - список IP-адресов, связанных с текущим хостом
whoami - выводит имя текущего пользователя, под которым вы вошли в систему

ssh-keygen -t rsa -b 4096 -C "<email>" -  команда для генерации пары SSH-ключей (публичного и приватного) с использованием алгоритма RSA и битовой длиной 
  4096 для безопасной аутентификации на удаленных серверах с использованием SSH, -t rsa - указывает тип ключа (RSA). -b 4096 - битовая длину ключа (4096 
  бит для повышенной безопасности), -C "<email>" - добавляет комментарий к ключу (email), который помогает вам идентифицировать ключ.
ssh -v -i ~/.ssh/google <user_name>@<IP-adress> - выполняет SSH-подключение к удаленному серверу с IP-адресом <IP-adress> от имени пользователя <user_name>, 
  используя ключ SSH, указанный опцией -i. Опция -v включает подробный режим вывода для отладки и отслеживания подключения.
ssh -p 8022 <user_name>@localhost - выполняет SSH-подключение, к локальному хосту (localhost) на порт 8022, указанный опцией -p, от имени пользователя user_name

pip install package_name==version_number - установка конкретной версии пакета
pip install --upgrade package_name - обновление пакета
pip uninstall package_name - удаление пакета
pip list - показать установленные пакеты
pip freeze > requirements.txt - создание файла зависимостей (requirements.txt)
pip install -r requirements.txt - установка пакетов из файла зависимостей
source venv/bin/activate - активировать виртуальную среду Python
deactivate - деактивировать виртуальную среду Python

ПУНКТ 2. Консольные команды git
Ниже перечислены основные команды git (системы контроля версий):

git init - создает новый репозиторий git в текущей директории
git clone <URL_удаленного_репозитория> - копирует существующий удалённый репозиторий на GitHub в локальную директорию
git add <file_name> - добавления изменений в индекс (staging area) в git (добавление в отслеживаемое для последующего коммита)
git add . - добаление всех файлов в текущей директории в ослеживаемое (кроме указанных в .gitignore)
git status - отображает текущее состояние репозитория git, включая изменения, не добавленные в индекс
git commit -m "message" - создание нового коммита с указанным сообщением "message"
git log - отображает список коммитов в репозитории git
git log --graph - просмотр истории коммитов в виде графа, что позволяет визуально представить ветвление и объединение веток
git remote add <origin> <URL_удаленного_репозитория> - связать удалённый репозиторий "origin" и локальный репозиторий 
git remote set-url <origin> <URL_удаленного_репозитория> - изменение URL удаленного репозитория с именем origin
git push -u <origin> - отправляет локальные изменения в ветке в удаленный репозиторий "origin"
  "origin" является обычным именем, используемым для ссылки на удаленный репозиторий по умолчанию, но вы можете использовать любое другое имя вместо него.
  Опция -u используется для установки отслеживаемой ветки, чтобы в будущем использовать git push без явного указания имени ветки и удаленного репозитория.
git pull <origin> <branch_name> - получает изменения из удаленной ветки <branch_name> в удаленном репозитории origin и объединяет их с текущей веткой
git pull - используется для получения и объединения изменений из удаленного репозитория в локальный репозиторий. Она включает в себя две операции: 
  git fetch - получает изменения из удаленного репозитория, и git merge, которая объединяет эти изменения с вашей текущей веткой
git merge <branch_name> - объединяет изменения <branch_name> в другую (на которой находимся)
git branch - отображает список веток в репозитории git и текущую активную ветку
git branch -d <branch_name> - удаление ветки <branch_name>
git branch -a - список всех локальных и удалённых веток
git checkout <branch_name/commit_hash> - переключает между ветками/восстанавливает файлы из предыдущих коммитов
git checkout -b <branch_name> - создать ветку <branch_name> и сразу переключиться на неё

Ниже перечислены дополнительные команды git (системы контроля версий):

git remote show origin - отобразит информацию о удаленном репозитории "origin", включая URL удаленного репозитория, текущую ветку и список доступных 
  веток на удаленном репозитории. Вы также увидите информацию о локальных ветках, которые отслеживаются удаленными ветками.
git remote remove origin - используется для удаления связи удалённого репозитория с именем "origin" и вашего локального git репозитория
git remote -v - вывод списка всех удаленных репозиториев, связанных с вашим локальным репозиторием git
git push <branch_name> - отправка локальной ветки <branch_name> на удалённый репозиторий
git fetch origin - получает изменения из удаленного репозитория "origin" и обновляет информацию о ветках и коммитах в локальном репозитории

git log origin/main ^main - просмотреть коммиты, которые есть в удаленной ветке, но отсутствуют в вашей текущей ветке
git log --all --decorate --oneline --graph - показывает историю коммитов с краткими информацией о каждом коммите + графическое представление ветвлений и слияний
git show - показывает информацию о выбранном коммите, включая список изменений, внесенных в файлы
git blame <file> - показывает автора и последние изменения для каждой строки указанного файла
git clean -f -d - удаляет файлы, которые не отслеживаются git, то есть файлы, которые не были добавлены в индекс с помощью git add
  -f (или --force) означает форсированное удаление, и -d означает удаление незамеченных директорий

git diff - выдаст различия между вашим текущим рабочим деревом (working tree) и индексом (index), изменения не добавленные в индекс для коммита
git diff <1 commit_hash> <2 commit_hash> <file_name> - просмотреть изменения между коммитами в файле
git diff <1 commit_hash> <2 commit_hash> - просмотреть изменения во всём проекте между коммитами
git diff <commit_hash> - сравнить коммит с последней закоммиченной версией

git restore --staged <file> - сбросит изменения в указанном файле, которые были добавлены в индекс
git restore <file> - отменит все изменения в указанном файле и вернёт его к состоянию в последнем коммите
git restore <commit_hash> -- <file> - восстановит указанный файл в состояние, которое он имел в указанном коммите
git clean -f - удаление непроиндексированных файлов из вашего рабочего каталога в git
git rm --cached <file> - удаление файла закомиченного ранее из отслеживаемого (предварительно добавить в .gitignore)

git stash - используется для временного сохранения изменений, чтобы переключаться на другую ветку без необходимости коммитить эти изменения
git stash pop - извлечение (возврата) последнего сохраненного состояния из stash и применения его к текущей ветке
git stash list - просмотр списка всех сохраненных состояний (stash) в вашем репозитории
git stash drop <N> - удаление конкретного сохраненного состояния (stash) из списка, <N> представляет собой номер stash-а, который вы хотите удалить

git revert <commit_hash> -  создаст новый коммит, который отменяет изменения, внесенные указанным <commit_hash>, и добавит его в историю
git revert <commit_hash> - отменяет изменения указанного коммита, но оставляет историю без изменений
git rebase <branch> - используется для переоснования (rebase) коммитов на другую ветку или для объединения последовательности коммитов в один коммит
  При выполнении git rebase изменяется история коммитов, перемещая коммиты на новое место или объединяя их

git merge --abort - отмены незавершенного процесса слияния в git. Если вы находитесь в состоянии конфликта слияния
git merge --squash <branch_name> - слияние изменений из указанной ветки <branch_name> в текущую ветку с опцией --squash. Эта опция позволяет 
  объединить все коммиты из указанной ветки в один коммит с целью создания чистой и лаконичной истории коммитов

git commit --amend --no-edit - изменения последнего коммита без изменения его сообщения
git commit --amend -m "new commit message" - изменения последнего коммита и изменение его сообщения на new commit message

git config --global user.name "<name>" -  установка глобального имени пользователя в git
git config --global user.email "<email>" - установка глобального email пользователя в git

git cherry-pick <commit_hash> - создаёт новый коммит, выбирает и применяет конкретные изменения указанного <commit_hash> из другой ветки и применить их в текущей ветке
git cherry-pick <commit_hash1> <commit_hash2> - применяет несколько коммитов, указанных в <commit_hash1> и <commit_hash2>, создавая для каждого новый коммит в текущей ветке
git cherry-pick <source_branch> - применяет последний коммит из указанной ветки <source_branch> в текущей ветке
git cherry-pick -Xtheirs <commit_hash> - применяет изменения из указанного <commit_hash>, разрешая все конфликты в пользу изменений из другой ветки (со стратегией "theirs")
git cherry-pick --no-commit <commit_hash> - применяет изменения из указанного <commit_hash> (полезно, перед внесением изменений перед созданием коммита)
git cherry-pick origin/<source_branch> - применяет последний коммит из удаленной ветки <source_branch> в текущей ветке

Варианты использования команды git reset позволяют изменять состояние коммитов, индекса и рабочего каталога:

git reset <commit_hash> - отменяет изменения и возвращает репозиторий к предыдущему состоянию.
git reset --merge <commit_hash> - отмена merge, возвращение к коммиту <commit_hash> до слияния
git reset --soft <commit_hash> - перемещение указателя HEAD и текущей ветки на указанный коммит, при этом сохраняя изменения из коммита и оставляя их в индексе 
  Эта команда позволяет "отменить" коммит и вернуться к предыдущему состоянию, при этом сохраняя изменения в рабочей директории и индексе для последующего коммита
git reset --mixed <commit_hash> - перемещение указателя HEAD и текущей ветки на указанный коммит, при этом отменяя изменения в индексе (staging area) и оставляя 
  изменения в рабочей директории. Отменяет коммит и возвращает к предыдущему состоянию, при этом сохраняя изменения в рабочей директории, но удаляя их из индекса
git reset --hard <commit_hash> - перемещение указателя HEAD и текущей ветки на указанный коммит и одновременного удаления всех изменений в рабочей директории и индексе

ПУНКТ 3. Работа с удалёнными репозиториями
Последовательность команд, предлагаемая при создании нового удалённого репозитория на GitHub:

git remote add origin <URL_удаленного_репозитория> - используется для добавления удаленного репозитория с именем "origin" в локальный репозиторий git
git branch -M main - изменяет имя текущей ветки на main и обновляет ссылки на ветку в локальном репозитории
git push -u origin main - используется для отправки изменений из локальной ветки main в удаленный репозиторий с именем origin

Последовательность операций для выполнения Pull Request (запроса на слияние) в GitHub / Merge Request в GitLab:

1) Определиться как именно будет выглядеть Pull Request: 
- PR может быть сделан непосредственно в свой личный репозиторий (личным также считается репозиторий созданный для личного аккаунта с помощью fork)
- PR может быть сделан непосредственно в репозиторий пользователя на GitHub (репозиторий пользователя должен быть публичным)
- PR может быть сделан непосредственно в репозиторий GitHub организации (при этом репозиторий может быть приватным,а fork отлючен)
2) Склонируйте версию удалённого репозитория на локальную директорию с помощью команды git clone, используя Https на Windows или Ssh на Unix-системах
3) Создайте новую ветку и переключитесь на неё с помощью команды git checkout -b <new-branch> и внесите свои изменения
4) Фиксируйте изменения с помощью команды git add для выбранных файлов и выполните команду git commit для сохранения изменений
5) Добавьте расположение git remote add origin <URL_удаленного_репозитория> или проверьте текущее git remote -v на правильность отправки
6) Отправьте вашу версию локальной ветки в удалённый репозиторий на платформу командой git push origin <new-branch>
7) На странице удалённого репозитория на платформе (GitHub или GitLab) откройте вкладку "Pull Request" или "Merge Request" 
  и создайте новый запрос на слияние, выбрав вашу ветку для слияния с главной (master или main)
8) Заполните необходимую информацию о запросе на слияние, включая заголовок, описание и другие детали
9) Нажмите кнопку "Создать Pull Request" или "Создать Merge Request" для отправки запроса на слияние. Укажите описание и рецензентов.
10) После review кода. Внесите необходимые изменения в вашу ветку git commit и обновите запрос на слияние git push, если требуется.
11) Если изменения в запросе на слияние получили одобрение, они могут быть объединены (слиты) с целевой веткой проекта.
12) Если изменения не соответствуют требованиям проекта или нуждаются в доработке, запрос на слияние может быть закрыт или отклонен. 
  В этом случае внесите необходимые изменения и создайте новый запрос на слияние.

После выполнения Pull Request (PR) в GitHub или Merge Request (MR) в GitLab, в зависимости от рассмотрения и утверждения изменений, могут быть следующие дальнейшие операции:

Merge (слияние): Если изменения, представленные в Pull Request (Merge Request), рассмотрены и утверждены, они могут быть объединены (слиты) с целевой веткой проекта.
В результате изменения из PR (MR) будут включены в основную линию разработки проекта. Существует 3 варианта слияния:
- Create a merge commit: При выборе этого варианта будет создан новый коммит слияния (merge commit), который объединит изменения из PR с целевой веткой. Этот коммит 
    будет содержать информацию о слиянии и оригинальные коммиты из PR, сохраняя полную историю изменений.
- Squash and merge: При выборе этого варианта все коммиты из PR будут сжаты в один коммит перед слиянием. Это полезно, если в PR было много коммитов, и вы хотите 
    упростить историю проекта, оставив только основные изменения.
- Rebase and merge: При выборе этого варианта коммиты из PR будут перебазированы (rebased) на верхушку целевой ветки, а затем они будут объединены. 
    Этот метод также помогает поддерживать чистую историю коммитов, но он может потребовать больше усилий при разрешении конфликтов.

Close (закрытие): Если изменения, представленные в PR, не соответствуют требованиям проекта или нуждаются в доработке, PR может быть закрыт без слияния. 
В этом случае разработчику может быть предложено внести изменения или устранить замечания, после чего можно создать новый PR с исправлениями. Закрытый PR все 
еще остается доступным для просмотра и архивирован в истории проекта.

Discussion (обсуждение): При рассмотрении PR могут возникать комментарии, предложения или вопросы от других разработчиков. 
В таком случае можно провести обсуждение изменений, отвечать на комментарии, решать возникающие вопросы и работать над улучшением кода на основе обратной связи.

Update (обновление): Если после открытия PR в целевой ветке произошли новые изменения, разработчик может обновить свою ветку и PR, чтобы включить последние 
изменения перед рассмотрением. Это помогает обеспечить актуальность и соответствие PR последнему состоянию проекта.

Reject (отклонение): Если изменения, представленные в PR, не соответствуют требованиям проекта или нуждаются в доработке, PR может быть отклонен. В этом случае 
разработчику может быть предложено внести изменения или устранить замечания, после чего можно создать новый PR с исправлениями.

ПУНКТ 4. Правила работы в git flow
1. Разработка новой функциональной или исправлений начинается от dev ветки
2. Название ветки ED23101-<task_number>/<task-description>. Пример ED23101-45/pagination-lessons-API
3. Шаблон названия коммитов - type(scope): Описание. Пример feat(JIRA-45): Добавлена пагинация уроков
  types: 
  feat - добавляет новую функцию в ваш код 
  fix - исправляет баг в вашем коде
  refactor - рефакторинг кода
  build - изменения, связанные с сборкой проекта или настройкой среды разработки
  chore - задачи, связанные с рутинными обслуживающими работами, которые не являются добавлением новой функциональности или исправлением ошибок
  ci - изменения в настройке системы непрерывной интеграции (Continuous Integration)
  doc - обновления в документации проекта
  style - изменения, связанные с стилем кода, форматированием и прочими визуальными аспектами кода
  test - добавление или изменение тестов
  chore - задачи, связанные с сборкой и инфраструктурой
  revert - отмена предыдущих коммитов
  release - коммиты, связанные с релизами
4. После прохождения ревью и при аппруве pull request(PR) смержить функциональность в dev ветку
5. Вся функциональность должна быть доставлена в dev ветку в качестве 1 коммита. Для этого при merge должен быть выбран пункт `squash and merge`
6. При создании PRа укажите в описании ссылку на задачу в Jira + отметьте своего ментора в задаче, чтобы ему пришло уведомление на проверку

ПУНКТ 5. Вопросы на собеседованиях.
Чем отличается git merge от git rebase?

git merge и git rebase - это два различных способа объединения изменений из одной ветки в другую в системе контроля версий git.

git merge (слияние):

Слияние (merge) создает новый коммит, который комбинирует изменения из двух разных веток. Когда вы делаете слияние, Git создает дополнительный коммит, который 
объединяет изменения источника (обычно ветки, которую вы хотите влить) с целевой веткой (веткой, в которую вы хотите влить изменения).Результат слияния - это новый 
коммит с двумя предками, которые указывают на коммиты исходных веток. Ветка, в которую производится слияние, остается неизменной. Слияние не переписывает историю ветки.

git rebase (перебазирование):

Перебазирование (rebase) переносит последовательность коммитов из одной ветки и применяет их поверх другой ветки. Перебазирование переписывает историю целевой ветки 
таким образом, что коммиты из исходной ветки применяются непосредственно на верхушку целевой ветки. Как результат, история становится линейной и более плоской, без 
создания дополнительных коммитов для слияния. Перебазирование полезно, когда вы хотите иметь аккуратную, линейную историю коммитов. Выбор между merge и rebase зависит 
от ситуации и предпочтений разработчика:

Если вы хотите просто объединить изменения с другой веткой и сохранить историю коммитов обеих веток, тогда используйте merge.
Если вы хотите иметь чистую, линейную историю коммитов без дополнительных коммитов слияния, тогда используйте rebase.

Важное замечание: Не перебазируйте ветки, которые уже были опубликованы и доступны для других разработчиков, так как это может нарушить историю и привести 
к проблемам при совместной работе.
