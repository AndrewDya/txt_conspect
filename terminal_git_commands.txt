Команды в терминале для навигации между директориями (Windows и Unix-подобные системы):

cd ~ перейти в домашний каталог 
cd <directory_name> - перейти в указанную директорию
cd .. - перейти в родительскую директорию (на один уровень выше текущей)
cd / - перейти в корневую директорию
cd - - перейти в предыдущий каталог
cd /path/to/directory - укажите полный путь к каталогу, в который вы хотите перейти
cd <Tab> - нажмите Tab после ввода начальных символов имени каталога, и терминал автоматически дополнит имя каталога, если есть однозначное соответствие
clear - очистить консоль

Основные команды в терминале (Windows):

dir - отобразить список файлов и каталогов в текущем каталоге
dir /a - отобразить скрытые файлы и каталоги в текущем каталоге
mkdir <directory> - создание нового каталога
copy <source_file> <destination> - копирование файла
move <source> <destination> - перемещение (переименование) файла или каталога
del <file_or_directory> - удаление файла или каталога
venv\Scripts\activate - активировать виртуальную среду Python

Основные команды в терминале (Unix-подобные системы):

sudo <command> - выполнить команду от имени администратора (суперпользователя)
sudo apt update - обновить список доступных пакетов в системе
sudo apt install <package_name> - установить указанный пакет с использованием менеджера пакетов APT (Advanced Package Tool)
sudo apt upgrade - обновить установленные пакеты до последних версий

ip a - вывести информацию о сетевых интерфейсах и их настройках
ls - вывести список файлов и каталогов в текущей директории
ls -la - отобразить список файлов и каталогов в текущей директории
ls -lha - отобразить список файлов и каталогов в текущей директории в длинном формате, включая скрытые файлы
pwd - вывести путь к текущей директории (текущий рабочий каталог)
mkdir <directory> - создать новую директорию с указанным именем
rmdir <directory> - удалить пустую директорию
rm <file> - удалить указанный файл
cp <source> <destination> - скопировать файл или директорию из источника в место назначения
mv <source> <destination> - переместить файл или директорию из источника в место назначения
touch - создать новый пустой файл с указанным именем
cat <file> - вывести содержимое указанного файла в консоль
grep <pattern> <file> - найти строки в указанном файле, соответствующие заданному шаблону с использованием регулярных выражений
ping <hostname_or_ip> - протестировать соединение сетевого устройства с помощью ICMP-запросов
top - вывод информации о текущих процессах в системе
ps - вывести список всех запущенных процессов
source venv/bin/activate - активировать виртуальную среду Python

su - andrewdya
hostname -I
whoami
ssh-keygen -t rsa -b 2048 -f ~/.ssh/mykey -C "коммент" -f название
ssh -v -i ~/.ssh/google newandrew@35.203.76.25


Ниже перечислены основные команды git (системы контроля версий):

git init - создает новый репозиторий git в текущей директории
git clone <URL_удаленного_репозитория> - копирует существующий удалённый репозиторий на GitHub в локальную директорию
git add <имя_файла> - добавления изменений в индекс (staging area) в git (добавление в отслеживаемое для последующего коммита)
git add . - добаление всех файлов в текущей директории в ослеживаемое (кроме указанных в .gitignore)
git status - отображает текущее состояние репозитория git, включая изменения, не добавленные в индекс
git commit -m "message" - создание нового коммита с указанным сообщением "message"
git log - отображает список коммитов в репозитории git
git log --graph - просмотр истории коммитов в виде графа, что позволяет визуально представить ветвление и объединение веток
git remote add origin <URL_удаленного_репозитория> - связать удалённый репозиторий "origin" и локальный репозиторий 
git remote set-url origin <URL_удаленного_репозитория> - изменение URL удаленного репозитория с именем origin
git push -u origin - отправляет локальные изменения в ветке в удаленный репозиторий "origin"
  "origin" является обычным именем, используемым для ссылки на удаленный репозиторий по умолчанию, но вы можете использовать любое другое имя вместо него.
  Опция -u используется для установки отслеживаемой ветки, чтобы в будущем использовать git push без явного указания имени ветки и удаленного репозитория.
git pull origin <branch_name> - получает изменения из удаленной ветки <название_ветки> в удаленном репозитории origin и объединяет их с текущей веткой
git pull - используется для получения и объединения изменений из удаленного репозитория в локальный репозиторий. Она включает в себя две операции: 
git fetch, которая получает изменения из удаленного репозитория, и git merge, которая объединяет эти изменения с вашей текущей веткой
git merge <branch_name> - объединяет изменения <branch_name> в другую (на которой находимся)
git branch - отображает список веток в репозитории git и текущую активную ветку
git branch -d <branch_name> - удаление ветки <branch_name>
git branch -a - список всех локальных и удалённых веток
git checkout <branch_name/commit> - переключает между ветками/восстанавливает файлы из предыдущих коммитов
git checkout -b <branch_name> - создать ветку и сразу переключиться на неё

Ниже перечислены дополнительные команды git (системы контроля версий):

git remote show origin - отобразит информацию о удаленном репозитории "origin", включая URL удаленного репозитория, текущую ветку и список доступных 
  веток на удаленном репозитории. Вы также увидите информацию о локальных ветках, которые отслеживаются удаленными ветками.
git remote remove origin - используется для удаления связи удалённого репозитория с именем "origin" и вашего локального Git репозитория
git remote -v - вывод списка всех удаленных репозиториев, связанных с вашим локальным репозиторием git
git push <branch_name> - отправка локальной ветки <branch_name> на удалённый репозиторий
git fetch origin - получает изменения из удаленного репозитория "origin" и обновляет информацию о ветках и коммитах в локальном репозитории

git log origin/main ^main - просмотреть коммиты, которые есть в удаленной ветке, но отсутствуют в вашей текущей ветке
git log --all --decorate --oneline --graph - показывает историю коммитов с краткими информацией о каждом коммите + графическое представление ветвлений и слияний
git show - показывает информацию о выбранном коммите, включая список изменений, внесенных в файлы
git blame <file> - показывает автора и последние изменения для каждой строки указанного файла

git diff - выдаст различия между вашим текущим рабочим деревом (working tree) и индексом (index), изменения не добавленные в индекс для коммита
git diff <1 commit> <2 commit> <file_name> - просмотреть изменения между коммитами в файле
git diff <1 commit> <2 commit> - просмотреть изменения во всём проекте между коммитами
git diff <commit> - сравнить коммит с последней закоммиченной версией

git restore --staged <file> - сбросит изменения в указанном файле, которые были добавлены в индекс
git restore <file> - отменит все изменения в указанном файле и вернёт его к состоянию в последнем коммите
git restore <commit> -- <file> - восстановит указанный файл в состояние, которое он имел в указанном коммите
git clean -f - удаление непроиндексированных файлов из вашего рабочего каталога в Git
git rm --cached <file> - удаление файла закомиченного ранее из отслеживаемого (предварительно добавить в .gitignore)

git stash - используется для временного сохранения изменений, чтобы переключаться на другую ветку без необходимости коммитить эти изменения
git stash pop - извлечение (возврата) последнего сохраненного состояния из stash и применения его к текущей ветке
git stash list - просмотр списка всех сохраненных состояний (stash) в вашем репозитории
git stash drop <N> - удаление конкретного сохраненного состояния (stash) из списка, <N> представляет собой номер stash-а, который вы хотите удалить

git revert <commit> -  создаст новый коммит, который отменяет изменения, внесенные указанным <commit>, и добавит его в историю
git revert <commit_hash> - отменяет изменения указанного коммита, но оставляет историю без изменений
git rebase <branch> - используется для переоснования (rebase) коммитов на другую ветку или для объединения последовательности коммитов в один коммит
  При выполнении git rebase изменяется история коммитов, перемещая коммиты на новое место или объединяя их.

git merge --abort - отмены незавершенного процесса слияния в Git. Если вы находитесь в состоянии конфликта слияния
git merge --squash <branch_name> - слияние изменений из указанной ветки <branch_name> в текущую ветку с опцией --squash. Эта опция позволяет 
  объединить все коммиты из указанной ветки в один коммит с целью создания чистой и лаконичной истории коммитов.

Варианты использования команды git reset позволяют изменять состояние коммитов, индекса и рабочего каталога.
git reset <commit> - отменяет изменения и возвращает репозиторий к предыдущему состоянию.
git reset --merge <commit> - отмена merge, возвращение к коммиту <commit> до слияния
git reset --soft <commit> - перемещение указателя HEAD и текущей ветки на указанный коммит, при этом сохраняя изменения из коммита и оставляя их в индексе 
  Эта команда позволяет "отменить" коммит и вернуться к предыдущему состоянию, при этом сохраняя изменения в рабочей директории и индексе для последующего коммита
git reset --mixed <commit> - перемещение указателя HEAD и текущей ветки на указанный коммит, при этом отменяя изменения в индексе (staging area) и оставляя 
  изменения в рабочей директории. Отменяет коммит и возвращает к предыдущему состоянию, при этом сохраняя изменения в рабочей директории, но удаляя их из индекса
git reset --hard <commit> - перемещение указателя HEAD и текущей ветки на указанный коммит и одновременного удаления всех изменений в рабочей директории и индексе

git commit --amend --no-edit - изменения последнего коммита без изменения его сообщения
git commit --amend -m "New commit message" - изменения последнего коммита и изменение его сообщения на New commit message

git config --global user.name "<name>" -  установка глобального имени пользователя в Git
git config --global user.email "<email>" - установка глобального email пользователя в Git
ssh-keygen -t ed25519 -C "email" - генерации SSH-ключа типа ed25519 с указанием электронной почты в качестве комментария

Последовательность команд, предлагаемая при создании нового удалённого репозитория на GitHub:

git remote add origin <URL_удаленного_репозитория> - используется для добавления удаленного репозитория с именем "origin" в локальный репозиторий Git. 
git branch -M main - изменяет имя текущей ветки на main и обновляет ссылки на ветку в локальном репозитории.
git push -u origin main - используется для отправки изменений из локальной ветки main в удаленный репозиторий с именем origin. 


Последовательность операций для выполнения Pull Request (запроса на слияние) в GitHub и Merge Request (запроса на слияние) 
в GitLab может быть объединена в следующую общую последовательность:

1) Создайте форк (fork) выбранного удалённого репозитория на платформе (GitHub или GitLab) (если вы хотите отправить запрос на слияние другому пользователю).
2) Склонируйте (clone) свою версию удалённого репозитория на локальную директорию с помощью команды git clone.
3) Создайте новую ветку (branch), переключитесь на неё с помощью команды git checkout -b <new-branch> и внесите свои изменения.
4) Фиксируйте изменения с помощью команды git add для выбранных файлов и выполните команду git commit для сохранения изменений.
5) Отправьте вашу версию локальной ветки в свой удалённый репозиторий на платформе командой git push (например, git push origin <new-branch>).
6) На странице вашего удалённого репозитория на платформе (GitHub или GitLab) откройте вкладку "Pull Request" или "Merge Request" 
  и создайте новый запрос на слияние, выбрав вашу ветку для слияния с главной (master или main).
7) Заполните необходимую информацию о запросе на слияние, включая заголовок, описание и другие детали.
8) Нажмите кнопку "Создать Pull Request" или "Создать Merge Request" для отправки запроса на слияние.
9) В процессе рассмотрения изменений могут возникать комментарии и обсуждения. Внесите необходимые изменения в вашу ветку 
  и обновите запрос на слияние, если требуется.
10) Если изменения в запросе на слияние получили одобрение, они могут быть объединены (слиты) с целевой веткой проекта.
11) Если изменения не соответствуют требованиям проекта или нуждаются в доработке, запрос на слияние может быть закрыт или отклонен. 
В этом случае внесите необходимые изменения и создайте новый запрос на слияние.

После выполнения Pull Request в GitHub или Merge Request в GitLab, в зависимости от рассмотрения и утверждения изменений, могут быть следующие дальнейшие операции:

Merge (слияние): Если изменения, представленные в Pull Request (Merge Request), рассмотрены и утверждены, они могут быть объединены (слиты) с целевой веткой проекта.
В результате изменения из PR (Merge Request) будут включены в основную линию разработки проекта.

Close (закрытие): Если изменения, представленные в Pull Request (Merge Request), не соответствуют требованиям проекта или нуждаются в доработке, Pull Request 
(Merge Request) может быть закрыт без слияния. В этом случае разработчику может быть предложено внести изменения или устранить замечания, после чего можно создать 
новый Pull Request (Merge Request) с исправлениями. Закрытый Pull Request (Merge Request) все еще остается доступным для просмотра и архивирован в истории проекта.

Discussion (обсуждение): При рассмотрении Pull Request (Merge Request) могут возникать комментарии, предложения или вопросы от других разработчиков. 
В таком случае можно провести обсуждение изменений, отвечать на комментарии, решать возникающие вопросы и работать над улучшением кода на основе обратной связи.

Update (обновление): Если после открытия Pull Request (Merge Request) в целевой ветке произошли новые изменения, разработчик может обновить свою ветку и Pull Request 
(Merge Request), чтобы включить последние изменения перед рассмотрением. Это помогает обеспечить актуальность и соответствие Pull Request (Merge Request) последнему 
состоянию проекта.

Reject (отклонение): Если изменения, представленные в Pull Request (Merge Request), не соответствуют требованиям проекта или нуждаются в доработке, Pull Request 
(Merge Request) может быть отклонен. В этом случае разработчику может быть предложено внести изменения или устранить замечания, после чего можно создать новый PR 
(Merge Request) с исправлениями.


Чем отличается git merge от git rebase?

git merge и git rebase - это два различных способа объединения изменений из одной ветки в другую в системе контроля версий Git.

Git Merge (слияние):

Слияние (merge) создает новый коммит, который комбинирует изменения из двух разных веток. Когда вы делаете слияние, Git создает дополнительный коммит, который 
объединяет изменения источника (обычно ветки, которую вы хотите влить) с целевой веткой (веткой, в которую вы хотите влить изменения).Результат слияния - это новый 
коммит с двумя предками, которые указывают на коммиты исходных веток.Ветка, в которую производится слияние, остается неизменной. Слияние не переписывает историю ветки.

Git Rebase (перебазирование):

Перебазирование (rebase) переносит последовательность коммитов из одной ветки и применяет их поверх другой ветки. Перебазирование переписывает историю целевой ветки 
таким образом, что коммиты из исходной ветки применяются непосредственно на верхушку целевой ветки. Как результат, история становится линейной и более плоской, без 
создания дополнительных коммитов для слияния. Перебазирование полезно, когда вы хотите иметь аккуратную, линейную историю коммитов. Выбор между merge и rebase зависит 
от ситуации и предпочтений разработчика:

Если вы хотите просто объединить изменения с другой веткой и сохранить историю коммитов обеих веток, тогда используйте merge.
Если вы хотите иметь чистую, линейную историю коммитов без дополнительных коммитов слияния, тогда используйте rebase.

Важное замечание: Не перебазируйте ветки, которые уже были опубликованы и доступны для других разработчиков, так как это может нарушить историю и привести 
к проблемам при совместной работе.